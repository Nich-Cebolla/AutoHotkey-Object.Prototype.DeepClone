[color=#800000][size=150]Description[/size][/color]
[color=#000000][size=125]Deep clones an object, with an option to specify a maximum depth.
This function works by first identifying the base type. For most types, including custom types, DeepClone will produce an object that is the same type as the original, and will have the same methods and properties available as the original. See "Limitations" for situations when this may not be possible.

After identifying the base type and constructing the new object, the original object's properties are iterated, recursively deep cloning any nested objects. For dynamic properties, the [c]GetOwnPropDesc[/c] function is called, and the result is assigned directly to the new object's property. See [url]https://www.autohotkey.com/docs/v2/lib/Object.htm#GetOwnPropDesc[/url] for more information.

If the original object is (or inherits from) Array or Map, any contained items are copied as well, recursively deep cloning any values which are objects.

[c]DeepClone[/c] gracefully handles duplicate objects by keeping track of the Ptr addresses of each cloned object. When [c]DeepClone[/c] encounters an object that has been deep cloned already, [c]DeepClone[/c] correctly assigns a reference to the copy of said object, instead of deep cloning the object again.
[/size][/color]

[color=#800000][size=150]Additional Features[/size][/color]
[color=#000000][size=125][c]DeepClone[/c] has one (included) dependency, function [c]GetObjectFromString[/c]. [c]GetObjectFromString[/c] takes a string input and returns a reference to the object. This is necessary to handle classes that have "." in the name, as [c]%'ParentClass.ChildClass'%[/c] does not work.[/size][/color]

[color=#800000][size=150]Github link[/size][/color]
[color=#000000][size=125][url]https://github.com/Nich-Cebolla/AutoHotkey-Object.Prototype.DeepClone[/url][/color]

[color=#800000][size=150]Parameters[/size][/color]
- [size=115]@param {Object} [color=#8000BF]Self[/color] - The object to be deep cloned. If calling this from an instance, exclude this parameter.[/size]
- [size=115]@param {Integer} [color=#8000BF][Depth=-1][/color]  - The maximum depth to clone. A value of -1 indicates no limit.[/size]

[color=#800000][size=150]Limitations[/size][/color]
[color=#000000][size=125]Though any object may be deep cloned, the function may fail to set the correct type in some situations. [c]DeepClone[/c] sets the object type by following this sequence of actions:
- [c]DeepClone[/c] attempts to create an instance of the object's class. For objects which are class objects, [c]DeepClone[/c] creates an instance of [c]Class[/c].
- If this fails (for example, if the constructor requires input parameters), [c]DeepClone[/c] checks if the object inherits from [c]Map[/c] or [c]Array[/c], and creates a new object from the respective class. If the object does not inherit from [c]Map[/c] or [c]Array[/c], then an instance of [c]Object[/c] is created.
- The new object's base is re-assigned to be the same as the original's base. This is where failure will occur for some types, because AutoHotkey prevents assigning a base type in situations where the object and the target base object are fundamentally different. If this occurs, [c]DeepClone[/c] continues to deep clone the object, but the new object remains an instance of [c]Object[/c]. The primary consequence of this is that some methods which get added to the new object would be invalid, and any properties that refer to something inherent to the original base type would be meaningless in relation to the new object.[/size][/color]

[color=#800000][size=150]Object.Prototype.DeepClone.ahk[/size][/color]

[code]

Object.Prototype.DefineProp('DeepClone', { Call: OBJECT_DEEPCLONE })
/**
 * @description - Performs a deep clone, with an optional maximum depth.
 * @param {Object} Self - The object to be deep cloned. If calling this method from an instance,
 * exclude this parameter.
 * @param {Integer} [Depth=-1] - The maximum depth to clone. A value of -1 indicates no limit.
 * @returns {Object} - The deep cloned object.
 */
OBJECT_DEEPCLONE(Self, Depth := -1) {
    PtrList := Map(ObjPtr(Self), Result := _GetTarget(Self))
    CurrentDepth := 1
    return _Recurse(Result, Self, PtrList, &CurrentDepth)

    _Recurse(Target, Subject, PtrList, &CurrentDepth) {
        CurrentDepth++
        for Prop in Subject.OwnProps() {
            if Prop  == 'Base'
                continue
            Desc := Subject.GetOwnPropDesc(Prop)
            if Desc.HasOwnProp('Value') {
                if Type(Desc.Value) == 'ComValue' || Type(Desc.Value) == 'ComObject' {
                    Target.DefineProp(Prop, { Value: Desc.Value })
                    continue
                }
                if IsObject(Desc.Value) {
                    if PtrList.Has(ObjPtr(Desc.Value)) {
                        Target.DefineProp(Prop, { Value: PtrList[ObjPtr(Desc.Value)] })
                        continue
                    }
                    if Depth == -1 || CurrentDepth < Depth {
                        PtrList.Set(ObjPtr(Desc.Value), _Target := _GetTarget(Desc.Value))
                        Target.DefineProp(Prop, { Value: _Recurse(_Target, Desc.Value, PtrList, &CurrentDepth) })
                    } else {
                        Target.DefineProp(Prop, { Value: Desc.Value })
                    }
                } else {
                    Target.DefineProp(Prop, { Value: Desc.Value })
                }
            } else {
                Target.DefineProp(Prop, Desc)
            }
        }
        ; If Subject is a custom class that has implemented an __Enum method, then the items are
        ; stored somewhere on a property anyway, and so repeating __Enum is likely not necessary.
        ; If the items are produced as a result of a calculation, then we do not need to capture
        ; those; __Enum can be called on the resulting cloned object to get them. Classes based on
        ; Array and Map are the exception, as they themselves are the containers of the items, and
        ; so there is no property from which to retrieve the items; we have to all __Enum to get them.
        if Target is Array {
            n := Flag := 0
            loop {
                Target.Length += 1000
                loop 1000 {
                    if !Subject.Has(++n) {
                        Flag := 1
                        break
                    }
                    Val := Subject[n]
                    if Type(Val) == 'ComValue' || Type(Val) == 'ComObject' {
                        Target[n] := Val
                        continue
                    }
                    if IsObject(Val) {
                        if PtrList.Has(ObjPtr(Val)) {
                            Target[n] := PtrList[ObjPtr(Val)]
                            continue
                        }
                        if Depth == -1 || CurrentDepth < Depth {
                            PtrList.Set(ObjPtr(Val), _Target := _GetTarget(Val))
                            Target[n] :=  _Recurse(_Target, Val, PtrList, &CurrentDepth)
                        } else {
                            Target[n] := Val
                        }
                    } else {
                        Target[n] := Val
                    }
                }
                if Flag
                    break
            }
            Target.Length := n - 1
        } else if Target is Map {
            for Key, Val in Subject {
                if Type(Val) == 'ComValue' || Type(Val) == 'ComObject' {
                    Target[Key] := Val
                    continue
                }
                if IsObject(Val) {
                    if PtrList.Has(ObjPtr(Val)) {
                        Target[Key] := PtrList[ObjPtr(Val)]
                        continue
                    }
                    if Depth == -1 || CurrentDepth < Depth {
                        PtrList.Set(ObjPtr(Val), _Target := _GetTarget(Val))
                        Target[Key] :=  _Recurse(_Target, Val, PtrList, &CurrentDepth)
                    } else {
                        Target[Key] := Val
                    }
                } else {
                    Target[Key] := Val
                }
            }
        }
        CurrentDepth--
        return Target
    }

    _GetTarget(Subject) {
        if Type(Subject) == 'Prototype' {
            Target := _GetTargetHelper(Subject.__Class)
        } else {
            obj := Subject.Base
            while !obj.HasOwnProp('__Class') {
                obj := obj.Base
                if A_Index >= 15 ; Arbitrary limit to prevent infininite loop.
                    throw Error('Failed to identify subject base type.', -1)
            }
            Target := _GetTargetHelper(obj.__Class)
        }
        try
            ObjSetBase(Target, Subject.Base)
        return Target

        _GetTargetHelper(ClassString) {
            try
                return GetObjectFromString(ClassString)()
            catch {
                if Subject Is Map {
                    return Map()
                } else if Subject is Array {
                    return Array()
                } else {
                    return Object()
                }
            }
        }
    }
}

/**
 * @description -
 * Use this function when you need to convert a string to an object reference, and the object
 * is nested within an object path. For example, we cannot get a reference to the class `Gui.Control`
 * by setting the string in double derefs like this: `obj := %'Gui.Control'%. Instead, we have to
 * traverse the path to get each object along the way, which is what this function does.
 * @param {String} Path - The object path.
 * @returns {*} - The object if it exists in the scope. Else, returns an empty string.
 * @example
    class MyClass {
        class MyNestedClass {
            static MyStaticProp := {prop1_1: 1, prop1_2: {prop2_1: {prop3_1: 'Hello, World!'}}}
        }
    }
    obj := GetObjectFromString('MyClass.MyNestedClass.MyStaticProp.prop1_2.prop2_1')
    OutputDebug(obj.prop3_1) ; Hello, World!
 * @
 */
GetObjectFromString(Path) {
    Split := StrSplit(Path, '.')
    if !IsSet(%Split[1]%)
        return
    OutObj := %Split[1]%
    i := 1
    while ++i <= Split.Length {
        if !OutObj.HasOwnProp(Split[i])
            return
        OutObj := OutObj.%Split[i]%
    }
    return OutObj
}

[/code]

[color=#800000][size=150]DeepCone-test.ahk[/size][/color]

[code]

#Include Object.Prototype.DeepClone.ahk
/*
    I just load this in a debugger and put a breakpoint on "sleep 1" to inspect it.
*/
class TestObject {
    static Get(TestID) {
        switch TestID {
            case 1: return TestObject.A_Object
        }
    }
    
    static A_Object := {
        B1_Obj: {C1_Obj: {D1_Prop: 'Val'}, C1_Map: Map('D1_Item', 'Val'), C1_Array: ['Val']}
      , B2_Map: Map('C2_Obj', {D2_Prop: 'Val'}, 'C2_Map', Map('D2_Item', 'Val'), 'C2_Array', ['Val'])
      , B3_Array: [{D3_Prop: 'Val'}, Map('D3_Item', 'Val'), ['Val']]
    }
    static A_Map := Map(
        'B1_Obj', {C1_Obj: {D1_Prop: 'Val'}, C1_Map: Map('D1_Item', 'Val'), C1_Array: ['Val']}
      , 'B2_Map', Map('C2_Obj', {D2_Prop: 'Val'}, 'C2_Map', Map('D2_Item', 'Val'), 'C2_Array', ['Val'])
      , 'B3_Array', [{D3_Prop: 'Val'}, Map('D3_Item', 'Val'), ['Val']]
    )
    static A_Array := [
        {C1_Obj: {D1_Prop: 'Val'}, C1_Map: Map('D1_Item', 'Val'), C1_Array: ['Val']}
      , Map('C2_Obj', {D2_Prop: 'Val'}, 'C2_Map', Map('D2_Item', 'Val'), 'C2_Array', ['Val'])
      , [{D3_Prop: 'Val'}, Map('D3_Item', 'Val'), ['Val']]
    ]
    static ErrorProp {
        Get {
            return this.__ErrorProp
        }
    }
}

new := TestObject.DeepClone()

; To demonstrate that the new object is, indeed, new.
_RecurseDelete(TestObject)
_RecurseDelete(Obj) {
    list := []
    for Prop in Obj.OwnProps() {
        list.Push(Prop)
    }
    for Prop in list {
        Desc := Obj.GetOwnPropDesc(Prop)
        if Desc.HasOwnProp('Value') && IsObject(Desc.Value) {
            _RecurseDelete(Desc.Value)
        }
        Obj.DeleteProp(Prop)
    }
}

sleep 1

[/code]


[color=#800000][size=150]Changelog[/size][/color]
[color=#000000][size=120]2025-02-08[/size][/color]
- Uploaded library
